; == Either ==

(claim  Either.mapRight (Pi     ([LeftT U] [OldRightT U] [NewRightT U]) (->      (-> OldRightT NewRightT) (Either LeftT OldRightT)   (Either LeftT NewRightT))))
(define Either.mapRight (lambda ( LeftT     OldRightT     NewRightT   ) (lambda (f                        either                  )
  (ind-Either
    either
    (lambda (oldEither) (Either LeftT NewRightT))
    (lambda (l) (left l))
    (lambda (r) (right (f r)))
  )
)))

(claim  Either.flatMapRight (Pi     ([LeftT U] [OldRightT U] [NewRightT U]) (->      (-> OldRightT (Either LeftT NewRightT)) (Either LeftT OldRightT)   (Either LeftT NewRightT))))
(define Either.flatMapRight (lambda ( LeftT     OldRightT     NewRightT   ) (lambda (f                                       either                  )
  (ind-Either
    either
    (lambda (oldEither) (Either LeftT NewRightT))
    (lambda (l) (left l))
    (lambda (r)  (f r)  )
  )
)))


; == Maybe ==

(claim  Maybe   (->       U          U                      ))
(define Maybe   (lambda ( ValueT   ) (Either Trivial ValueT)))

(claim  nothing (Pi     ([ValueT U])             (Maybe ValueT)))
(define nothing (lambda ( ValueT   )             (left sole   )))

(claim  just    (Pi     ([ValueT U]) (-> ValueT  (Maybe ValueT))))
(define just    (lambda ( ValueT         value ) (right value ) ))


(claim  Maybe.map     (Pi     ([A U] [B U]) (->      (-> A B        ) (Maybe A)    (Maybe B)                                 )))
(define Maybe.map     (lambda ( A     B   ) (lambda (f                maybeA   )   (Either.mapRight     Trivial A B f maybeA))))

(claim  Maybe.flatMap (Pi     ([A U] [B U]) (->      (-> A (Maybe B)) (Maybe A)    (Maybe B)                                 )))
(define Maybe.flatMap (lambda ( A     B   ) (lambda (f                maybeA   )   (Either.flatMapRight Trivial A B f maybeA))))

; == Map ==

; Not sure how equality will work, keys might need to be restricted to Nats.
(claim  Map (->                  U        U         U))
(define Map (lambda            [ KeyT     ValueT   ]
              (List (Pair        KeyT     ValueT   ))))

; creates an empty map
(claim  mapOf (Pi              ([KeyT U] [ValueT U])
                (Map             KeyT     ValueT   )))
(define mapOf (lambda          ( KeyT     ValueT   )
                (the (List (Pair KeyT     ValueT   )) nil)))

; TODO not implemented yet, but you can listcons a key value pair to a map, if you're careful enough to not insert duplicate keys.
;(claim put (Pi ((KeyT U) (ValueT U))
;             (-> KeyT ValueT   (Map KeyT ValueT)))) 
;(define put (Pi ((KeyT U) (ValueT U)) TODO))

; List -> Map
(claim associateBy (Pi ([KeyT U] [ValueT U])
  (->
    (-> ValueT   KeyT)   ; key selector
    (List ValueT)        ; values

    (Map KeyT ValueT)))) ; result Map

(define associateBy (lambda (KeyT ValueT) (lambda (keySelector values)
  (rec-List
    values
    (mapOf KeyT ValueT)
    (lambda (value values result)
      (::
        (the (Pair KeyT ValueT) (cons (keySelector value) value))
        result))))))

#;(claim get (Pi
  ((KeyT U) (ValueT U))
  (-> KeyT (Map KeyT ValueT)   (Maybe ValueT))))
#;(define get (lambda (KeyT ValueT) (lambda (key map)
  (rec-List
    map
    (TODO empty maybe)
    (lambda (entry entries result)
    (TODO if (car entry) == key) then (Just (cdr entry)) else result )
    
    )
  )
))

#;(which-nat
  5 ; target (Number to check)
  'it-is-zero ; result if target is zero
  (lambda (five-minus-one) 'it-is-not-zero) ; lambda to run with the predecessor of target, if target is not null
)